{
  "version": 3,
  "sources": ["../src/extension.ts"],
  "sourcesContent": ["import * as vscode from 'vscode';\r\n\r\ntype Matches = (number | undefined)[];\r\n\r\nlet statusBar: vscode.StatusBarItem;\r\n\r\nlet searchInput: string = '';\r\nlet isSearchModeActive: boolean = false;\r\nlet searchContext: {\r\n  searchTerm: string;\r\n  matches: Matches;\r\n  currentIndex: number;\r\n} | null;\r\n\r\nfunction setStatusBarMessage(msg: string) {\r\n  statusBar.text = `${isSearchModeActive ? '\uD83D\uDD35' : ''} ${msg}`;\r\n}\r\n\r\ntype ExtensionSetting =\r\n  | 'showTooltipIfNoMatches'\r\n  | 'caseSensitiveSearch'\r\n  | 'minimumCharactersToExecuteSearch'\r\n  | 'matchesColor.foreground'\r\n  | 'matchesColor.background'\r\n  | 'currentMatchColor.foreground'\r\n  | 'currentMatchColor.background';\r\n\r\nfunction readConfiguration(settingKey: ExtensionSetting) {\r\n  const extensionConfig = vscode.workspace.getConfiguration('findAndJump');\r\n  const configValue = extensionConfig.get<string>(settingKey);\r\n\r\n  if (configValue === undefined) {\r\n    const msg = `Missing config value for ${settingKey}`;\r\n    showTooltipMessage(msg, 'error');\r\n    throw new Error(msg);\r\n  }\r\n\r\n  return configValue;\r\n}\r\n\r\n/**\r\n * This needs to be defined \"globally\" as `setDecorations` relies on a stable instance when overwriting one.\r\n * Without this, \"old\" (already applied) decorations would not be reset (e.g. when entering characters as search input).\r\n *\r\n * See: https://github.com/microsoft/vscode-extension-samples/issues/22\r\n */\r\nconst decorations = {\r\n  matches: vscode.window.createTextEditorDecorationType({\r\n    backgroundColor: readConfiguration('matchesColor.background'),\r\n    color: readConfiguration('matchesColor.foreground'),\r\n  }),\r\n  currentMatch: vscode.window.createTextEditorDecorationType({\r\n    backgroundColor: readConfiguration('currentMatchColor.background'),\r\n    color: readConfiguration('currentMatchColor.foreground'),\r\n  }),\r\n};\r\n\r\nfunction setTextDecoration(\r\n  activeTextEditor: vscode.TextEditor,\r\n  decorationOptions: vscode.DecorationOptions[],\r\n) {\r\n  activeTextEditor.setDecorations(decorations.matches, decorationOptions);\r\n}\r\n\r\nfunction showTooltipMessage(\r\n  msg: string,\r\n  type: 'default' | 'error' = 'default',\r\n) {\r\n  switch (type) {\r\n    case 'default': {\r\n      vscode.window.showInformationMessage(msg);\r\n      break;\r\n    }\r\n    case 'error': {\r\n      vscode.window.showErrorMessage(msg);\r\n      break;\r\n    }\r\n    default: {\r\n      // TypeScript hack for exhaustive switch check\r\n      const exhaustiveCheck: never = type;\r\n      throw new Error(`Unkown tooltip type: ${exhaustiveCheck}`);\r\n    }\r\n  }\r\n}\r\n\r\nfunction setInitialSearchModeMessage() {\r\n  setStatusBarMessage('Search mode active');\r\n}\r\n\r\nfunction setSearchModeStatus(isActiveNew: boolean) {\r\n  isSearchModeActive = isActiveNew;\r\n  vscode.commands.executeCommand(\r\n    'setContext',\r\n    'findAndJump.isSearchModeActive',\r\n    isActiveNew,\r\n  );\r\n}\r\n\r\nfunction initializeStatusBar() {\r\n  statusBar = vscode.window.createStatusBarItem(\r\n    vscode.StatusBarAlignment.Left,\r\n    100,\r\n  );\r\n  statusBar.command = 'findAndJump.exitSearchMode';\r\n  statusBar.tooltip = 'Click to exit search mode.';\r\n  statusBar.show();\r\n\r\n  setStatusBarMessage('Extension activated');\r\n}\r\n\r\nfunction createRange({\r\n  matchIndex,\r\n  searchTerm,\r\n  document,\r\n}: {\r\n  matchIndex: number | undefined;\r\n  searchTerm: string;\r\n  document: vscode.TextDocument;\r\n}) {\r\n  if (typeof matchIndex === 'undefined') {\r\n    showTooltipMessage(\r\n      'Something went wrong. See logs for more information. Error: Missing match index',\r\n    );\r\n    throw new Error('Missing match index');\r\n  }\r\n\r\n  const startPos = document.positionAt(matchIndex);\r\n  const endPos = document.positionAt(matchIndex + searchTerm.length);\r\n  const range = new vscode.Range(startPos, endPos);\r\n\r\n  return range;\r\n}\r\n\r\nfunction selectRange(range: vscode.Range, currentIndexNew: number) {\r\n  const activeTextEditor = vscode.window.activeTextEditor;\r\n\r\n  if (!activeTextEditor) {\r\n    throw new Error('No active text editor');\r\n  } else if (!searchContext) {\r\n    throw new Error('No search context');\r\n  } else {\r\n    // Set the active decoration for search result\r\n    activeTextEditor.setDecorations(decorations.currentMatch, [range]);\r\n    // Select the search result\r\n    activeTextEditor.selection = new vscode.Selection(range.start, range.end);\r\n    // Scroll to search result\r\n    activeTextEditor.revealRange(\r\n      range,\r\n      vscode.TextEditorRevealType.InCenterIfOutsideViewport,\r\n    );\r\n\r\n    /*\r\n     * We are programmatically changing the selection, so we need to save the new current index\r\n     * in the search context so \"cycling\" is aware of it.\r\n     */\r\n    searchContext.currentIndex = currentIndexNew;\r\n  }\r\n}\r\n\r\n/** Executed on activation. */\r\nexport function activate(context: vscode.ExtensionContext) {\r\n  console.debug('Activated');\r\n\r\n  initializeStatusBar();\r\n\r\n  const disposableCommandActivateSearchMode = vscode.commands.registerCommand(\r\n    'findAndJump.activateSearchMode',\r\n    () => {\r\n      console.debug('Command: activateSearchMode');\r\n\r\n      if (!isSearchModeActive) {\r\n        setSearchModeStatus(true);\r\n        setInitialSearchModeMessage();\r\n      }\r\n    },\r\n  );\r\n\r\n  const disposableCommandType = vscode.commands.registerCommand(\r\n    'type',\r\n    (event) => {\r\n      console.debug('Command: type');\r\n\r\n      if (isSearchModeActive) {\r\n        searchInput += event.text;\r\n        executeSearch(searchInput);\r\n      } else {\r\n        // Fall back to the default type command\r\n        vscode.commands.executeCommand('default:type', event);\r\n      }\r\n    },\r\n  );\r\n\r\n  const disposableCommandCaptureBackspace = vscode.commands.registerCommand(\r\n    'findAndJump.captureBackspace',\r\n    () => {\r\n      console.debug('Command: captureBackspace');\r\n\r\n      if (isSearchModeActive) {\r\n        // Handle backspace key: remove the last character\r\n        if (searchInput.length > 0) {\r\n          searchInput = searchInput.slice(0, -1);\r\n        }\r\n\r\n        // Only search if the input is at least 1 character\r\n        if (searchInput.length > 0) {\r\n          executeSearch(searchInput);\r\n        } else {\r\n          setInitialSearchModeMessage();\r\n        }\r\n      }\r\n    },\r\n  );\r\n\r\n  const disposableCommandExitSearchMode = vscode.commands.registerCommand(\r\n    'findAndJump.exitSearchMode',\r\n    () => {\r\n      console.debug('Command: exitSearchMode');\r\n\r\n      exitSearchMode();\r\n    },\r\n  );\r\n\r\n  const dispoCycleThrough = vscode.commands.registerCommand(\r\n    'findAndJump.cycleThroughMatches',\r\n    () => {\r\n      console.debug('Command: cycleThroughMatches');\r\n\r\n      executeCycleThrough('forwards');\r\n    },\r\n  );\r\n\r\n  const dispoCycleThroughBackwards = vscode.commands.registerCommand(\r\n    'findAndJump.cycleThroughMatchesBackwards',\r\n    () => {\r\n      console.debug('Command: cycleThroughMatchesBackwards');\r\n\r\n      executeCycleThrough('backwards');\r\n    },\r\n  );\r\n\r\n  context.subscriptions.push(\r\n    statusBar,\r\n    disposableCommandActivateSearchMode,\r\n    disposableCommandType,\r\n    dispoCycleThrough,\r\n    dispoCycleThroughBackwards,\r\n    disposableCommandCaptureBackspace,\r\n    disposableCommandExitSearchMode,\r\n  );\r\n}\r\n\r\ntype ClosestMatch = { range: vscode.Range; indexOfMatchDecorations: number };\r\n\r\nfunction findClosestMatch(\r\n  matchDecorations: vscode.DecorationOptions[],\r\n  currentSelectionPosition: vscode.Position,\r\n): ClosestMatch | null {\r\n  let diffLines = Number.MAX_SAFE_INTEGER;\r\n  let closestMatch: ClosestMatch | null = null;\r\n\r\n  function updateClosestMatch(range: vscode.Range, index: number) {\r\n    closestMatch = {\r\n      ...closestMatch,\r\n      range: range,\r\n      indexOfMatchDecorations: index,\r\n    };\r\n  }\r\n\r\n  matchDecorations.forEach((matchDecoration, idx) => {\r\n    const rangeCurrent = matchDecoration.range;\r\n\r\n    if (!closestMatch) {\r\n      updateClosestMatch(rangeCurrent, idx);\r\n    } else {\r\n      const diffCurrent = Math.abs(\r\n        currentSelectionPosition.line - rangeCurrent.start.line,\r\n      );\r\n\r\n      if (diffCurrent < diffLines) {\r\n        diffLines = diffCurrent;\r\n        updateClosestMatch(rangeCurrent, idx);\r\n      }\r\n    }\r\n  });\r\n\r\n  return closestMatch;\r\n}\r\n\r\nfunction executeCycleThrough(direction: 'forwards' | 'backwards' = 'forwards') {\r\n  if (!searchContext) {\r\n    throw new Error('Missing search context');\r\n  }\r\n\r\n  const indexOffsetForDirection = direction === 'forwards' ? 1 : -1;\r\n\r\n  // Determine index with modulo to jump to the first match after the last match\r\n  const newCurrentIndex =\r\n    (searchContext.currentIndex + indexOffsetForDirection) %\r\n    searchContext.matches.length;\r\n\r\n  searchContext.currentIndex = newCurrentIndex;\r\n\r\n  const matchIndex = searchContext.matches.at(searchContext.currentIndex);\r\n\r\n  const activeTextEditor = vscode.window.activeTextEditor;\r\n  if (!activeTextEditor) {\r\n    throw new Error('No active text editor');\r\n  } else {\r\n    const range = createRange({\r\n      matchIndex,\r\n      searchTerm: searchContext.searchTerm,\r\n      document: activeTextEditor.document,\r\n    });\r\n\r\n    selectRange(range, newCurrentIndex);\r\n  }\r\n}\r\n\r\nfunction executeSearch(searchTerm: string) {\r\n  console.debug('######## Executing search for: ', searchTerm);\r\n\r\n  const searchMsg = `Searching for: '${searchTerm}'`;\r\n\r\n  const noOfChars = searchTerm.length;\r\n  const minimumCharactersToExecuteSearch = Number(\r\n    readConfiguration('minimumCharactersToExecuteSearch'),\r\n  );\r\n  if (noOfChars < minimumCharactersToExecuteSearch) {\r\n    const noOfNeededChars = minimumCharactersToExecuteSearch - noOfChars;\r\n\r\n    setStatusBarMessage(\r\n      `${searchMsg} | Enter ${noOfNeededChars} more character${\r\n        noOfNeededChars > 1 ? 's' : ''\r\n      }.`,\r\n    );\r\n\r\n    return;\r\n  }\r\n\r\n  const activeTextEditor = vscode.window.activeTextEditor;\r\n  if (!activeTextEditor) {\r\n    showTooltipMessage('No active text editor.', 'error');\r\n\r\n    return;\r\n  }\r\n\r\n  const document = activeTextEditor.document;\r\n  const documentText = document.getText();\r\n  const isCaseSensitiveSearch = Boolean(\r\n    readConfiguration('caseSensitiveSearch'),\r\n  );\r\n  const flags = isCaseSensitiveSearch === true ? 'g' : 'gi';\r\n  const regex = new RegExp(searchTerm, flags);\r\n\r\n  const matches: Matches = Array.from(\r\n    documentText.matchAll(regex),\r\n    (match) => match.index,\r\n  );\r\n  const noOfMatches = matches.length;\r\n\r\n  if (noOfMatches === 0) {\r\n    if (searchContext?.searchTerm) {\r\n      searchContext.searchTerm = searchTerm;\r\n    }\r\n\r\n    setStatusBarMessage(`${searchMsg} | No matches`);\r\n\r\n    if (!!readConfiguration('showTooltipIfNoMatches')) {\r\n      showTooltipMessage(`No matches found for ${searchTerm}.`);\r\n    }\r\n    return;\r\n  } else {\r\n    setStatusBarMessage(\r\n      `${searchMsg} | ${noOfMatches} match${\r\n        noOfMatches === 1 ? '' : 'es | Press TAB to cycle through'\r\n      }`,\r\n    );\r\n  }\r\n\r\n  // Apply decorations to the matches\r\n  const matchDecorations: vscode.DecorationOptions[] = matches\r\n    .filter((matchIndex) => typeof matchIndex === 'number')\r\n    .map((matchIndex) => {\r\n      return {\r\n        range: createRange({\r\n          matchIndex,\r\n          searchTerm,\r\n          document: activeTextEditor.document,\r\n        }),\r\n      };\r\n    });\r\n\r\n  setTextDecoration(activeTextEditor, matchDecorations);\r\n\r\n  // Initially set the selection to the closest match\r\n  const closestMatch = findClosestMatch(\r\n    matchDecorations,\r\n    activeTextEditor.selection.start,\r\n  );\r\n\r\n  searchContext = {\r\n    searchTerm,\r\n    matches,\r\n    currentIndex: !closestMatch ? 0 : closestMatch.indexOfMatchDecorations,\r\n  };\r\n\r\n  if (!!closestMatch) {\r\n    selectRange(closestMatch.range, closestMatch.indexOfMatchDecorations);\r\n  }\r\n  console.debug('######## End of executing search');\r\n}\r\n\r\nfunction exitSearchMode() {\r\n  setSearchModeStatus(false);\r\n  resetState();\r\n\r\n  const msg = 'Exited search mode';\r\n  console.debug(msg);\r\n  setStatusBarMessage(msg);\r\n}\r\n\r\nfunction resetState() {\r\n  searchInput = '';\r\n  searchContext = null;\r\n\r\n  const activeTextEditor = vscode.window.activeTextEditor;\r\n  if (!activeTextEditor) {\r\n    throw new Error('No active text editor');\r\n  } else {\r\n    activeTextEditor.setDecorations(decorations.matches, []);\r\n    activeTextEditor.setDecorations(decorations.currentMatch, []);\r\n  }\r\n}\r\n\r\n/** Executed on deactivation. */\r\nexport function deactivate() {\r\n  console.debug('Deactivated');\r\n}\r\n"],
  "mappings": "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",
  "names": ["extension_exports", "__export", "activate", "deactivate", "__toCommonJS", "vscode", "statusBar", "searchInput", "isSearchModeActive", "searchContext", "setStatusBarMessage", "msg", "readConfiguration", "settingKey", "configValue", "showTooltipMessage", "decorations", "setTextDecoration", "activeTextEditor", "decorationOptions", "type", "exhaustiveCheck", "setInitialSearchModeMessage", "setSearchModeStatus", "isActiveNew", "initializeStatusBar", "createRange", "matchIndex", "searchTerm", "document", "startPos", "endPos", "selectRange", "range", "currentIndexNew", "context", "disposableCommandActivateSearchMode", "disposableCommandType", "event", "executeSearch", "disposableCommandCaptureBackspace", "disposableCommandExitSearchMode", "exitSearchMode", "dispoCycleThrough", "executeCycleThrough", "dispoCycleThroughBackwards", "findClosestMatch", "matchDecorations", "currentSelectionPosition", "diffLines", "closestMatch", "updateClosestMatch", "index", "matchDecoration", "idx", "rangeCurrent", "diffCurrent", "direction", "indexOffsetForDirection", "newCurrentIndex", "searchMsg", "noOfChars", "minimumCharactersToExecuteSearch", "noOfNeededChars", "documentText", "flags", "regex", "matches", "match", "noOfMatches", "resetState"]
}
